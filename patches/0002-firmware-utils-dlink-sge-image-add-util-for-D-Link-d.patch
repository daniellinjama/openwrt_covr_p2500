firmware-utils: dlink-sge-image: add util for D-Link devices by SGE

This tool will encrypt/decrypt factory images requiring the "SHRS" header
e.g. COVR-P2500, COVR-C1200, DIR-878, DIR-882, DIR-1960, DIR-2660, ...

Encryption is loosely based on a series of blogposts by ricksanchez [1]
and the provided code [2], as well as patches to qca-uboot found in the
GPL tarball released for D-Link COVR-P2500 Rev. A1 [3].

Further scripts (e.g. /lib/upgrade/) and keys were found in the GPL tarball
and/or rootfs of COVR-C1200 (the devices are based on OpenWrt Chaos Calmer
and failsafe can be entered by pressing 'f' on the serial console during
boot, allowing to access the file system of the running device).

[1] https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943
[2] https://github.com/0xricksanchez/dlink-decrypt
[3] https://tsd.dlink.com.tw/GPL.asp

Signed-off-by: Sebastian Schaper <openwrt@sebastianschaper.net>
---
 include/image-commands.mk                  |   5 +
 scripts/dlink-sge-signature.py             |  35 +++++
 target/linux/ath79/image/generic.mk        |   4 +++
 tools/firmware-utils/src/dlink-sge-image.c | 351 +++++++++++++++++++++
 tools/firmware-utils/src/dlink-sge-image.h |  86 +++++
 5 files changed, 481 insertions(+)
 create mode 100755 scripts/dlink-sge-signature.py
 create mode 100644 tools/firmware-utils/src/dlink-sge-image.c
 create mode 100644 tools/firmware-utils/src/dlink-sge-image.h

diff --git a/include/image-commands.mk b/include/image-commands.mk
--- a/include/image-commands.mk
+++ b/include/image-commands.mk
@@ -226,6 +226,11 @@ define Build/copy-file
 	cat "$(1)" > "$@"
 endef
 
+define Build/dlink-sge-image
+	$(STAGING_DIR_HOST)/bin/dlink-sge-image $@ $@.enc
+	mv $@.enc $@
+endef
+
 define Build/edimax-header
 	$(STAGING_DIR_HOST)/bin/mkedimaximg -i $@ -o $@.new $(1)
 	@mv $@.new $@
diff --git a/scripts/dlink-sge-signature.py b/scripts/dlink-sge-signature.py
new file mode 100755
--- /dev/null
+++ b/scripts/dlink-sge-signature.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python3
+# SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+#
+# Copyright (C) 2021 Sebastian Schaper <openwrt@sebastianschaper.net>
+#
+# append model string and gzip-based signature used by
+# certain D-Link devices manufactured by SGE / T&W.
+#
+# e.g. COVR-P2500 requires this to be appended to the
+# encrypted factory image, while for COVR-C1200 the
+# signature needs to be appended to the unencrypted payload
+#
+
+import gzip, hashlib, sys
+
+if len(sys.argv) != 3:
+    exit(f"usage: {sys.argv[0]} input.bin model_name")
+
+input_file = sys.argv[1]
+model_name = sys.argv[2]
+
+with open(input_file, "rb+") as fd:
+    input_bytes = fd.read()
+
+    gzipped = gzip.compress(input_bytes)[-8:-4]
+    m = hashlib.md5()
+    m.update(input_bytes)
+
+    fd.write(m.hexdigest().encode())
+    fd.write(f"\n{model_name}\n".encode())
+    fd.write(gzipped[::-1].hex().encode()) # change byte order
+
+    exit()
+
+exit(1)
diff --git a/target/linux/ath79/image/generic.mk b/target/linux/ath79/image/generic.mk
--- a/target/linux/ath79/image/generic.mk
+++ b/target/linux/ath79/image/generic.mk
@@ -32,6 +32,10 @@ define Build/cybertan-trx
 	-rm $@-empty.bin
 endef
 
+define Build/dlink-sge-signature
+	$(TOPDIR)/scripts/dlink-sge-signature.py $@ $(1)
+endef
+
 define Build/edimax-headers
 	$(eval edimax_magic=$(word 1,$(1)))
 	$(eval edimax_model=$(word 2,$(1)))
diff --git a/tools/firmware-utils/src/dlink-sge-image.c b/tools/firmware-utils/src/dlink-sge-image.c
new file mode 100644
--- /dev/null
+++ b/tools/firmware-utils/src/dlink-sge-image.c
@@ -0,0 +1,351 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+/*
+ * Copyright (C) 2021 Sebastian Schaper <openwrt@sebastianschaper.net>
+ *
+ * This tool encrypts factory images for certain D-Link Devices
+ * manufactured by SGE / T&W, e.g. COVR-C1200, COVR-P2500, DIR-882, ...
+ *
+ * Build instructions:
+ *   gcc -lcrypto dlink-sge-image.c -o dlink-sge-image
+ *
+ * Usage:
+ *   ./dlink-sge-image infile outfile [-d: decrypt]
+ *
+ */
+
+#include "dlink-sge-image.h"
+
+#include <openssl/aes.h>
+#include <openssl/pem.h>
+#include <openssl/rsa.h>
+#include <openssl/sha.h>
+
+#include <arpa/inet.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define BUFSIZE		4096
+
+#define HEAD_MAGIC		"SHRS"
+#define HEAD_MAGIC_LEN	4
+#define SHA512_DIGEST_LENGTH	64
+#define RSA_KEY_LENGTH_BYTES	512
+#define AES_BLOCK_SIZE	16
+#define HEADER_LEN		1756
+
+unsigned char aes_iv[AES_BLOCK_SIZE];
+
+unsigned char readbuf[BUFSIZE];
+unsigned char encbuf[BUFSIZE];
+
+unsigned int read_bytes;
+unsigned long read_total;
+unsigned int i;
+
+unsigned char vendor_key[AES_BLOCK_SIZE];
+AES_KEY enc_key;
+
+FILE *input_file;
+FILE *output_file;
+
+void image_encrypt(void)
+{
+	char buf[HEADER_LEN];
+	SHA512_CTX digest;
+	SHA512_CTX digest_post;
+	SHA512_CTX digest_vendor;
+	uint32_t payload_length_before, pad_len, sizebuf;
+	unsigned char md_before[SHA512_DIGEST_LENGTH];
+	unsigned char md_post[SHA512_DIGEST_LENGTH];
+	unsigned char md_vendor[SHA512_DIGEST_LENGTH];
+	unsigned char sigret[RSA_KEY_LENGTH_BYTES];
+	unsigned int siglen = RSA_KEY_LENGTH_BYTES;
+	char footer[] = {0x00, 0x00, 0x00, 0x00, 0x30};
+
+	// seek to position 1756 (begin of AES-encrypted data),
+	// write image headers later
+	memset(buf, 0, HEADER_LEN);
+	fwrite(&buf, 1, HEADER_LEN, output_file);
+
+	RSA *rsa = RSA_new();
+	BIO *rsa_private_bio = BIO_new_mem_buf(key2_pem, -1);
+
+	PEM_read_bio_RSAPrivateKey(rsa_private_bio, &rsa, NULL, NULL);
+
+	SHA512_Init(&digest);
+	SHA512_Init(&digest_post);
+
+	memcpy(&aes_iv, &salt, AES_BLOCK_SIZE);
+	AES_set_encrypt_key(&vendor_key[0], 128, &enc_key);
+
+	while ((read_bytes = fread(&readbuf, 1, BUFSIZE, input_file)) == BUFSIZE) {
+		SHA512_Update(&digest, &readbuf[0], read_bytes);
+		read_total += read_bytes;
+
+		AES_cbc_encrypt(&readbuf[0], encbuf, BUFSIZE, &enc_key, aes_iv, AES_ENCRYPT);
+		fwrite(&encbuf, 1, BUFSIZE, output_file);
+
+		SHA512_Update(&digest_post, &encbuf[0], BUFSIZE);
+	}
+
+	// handle last block of data (read_bytes < BUFSIZE)
+	SHA512_Update(&digest, &readbuf[0], read_bytes);
+	read_total += read_bytes;
+
+	pad_len = AES_BLOCK_SIZE - (read_total % AES_BLOCK_SIZE);
+	if (pad_len == 0)
+		pad_len = 16;
+	memset(&readbuf[read_bytes], 0, pad_len);
+
+	AES_cbc_encrypt(&readbuf[0], encbuf, read_bytes + pad_len, &enc_key, aes_iv, AES_ENCRYPT);
+	fwrite(&encbuf, 1, read_bytes + pad_len, output_file);
+
+	SHA512_Update(&digest_post, &encbuf[0], read_bytes + pad_len);
+
+	fclose(input_file);
+	payload_length_before = read_total;
+	printf("\npayload_length_before: %li\n", read_total);
+
+	// copy digest state, since we need another one with vendor key appended,
+	// without having to re-hash the whole file (SHA512_Final is destructive)
+	memcpy(&digest_vendor, &digest, sizeof(SHA512_CTX));
+
+	SHA512_Final(&md_before[0], &digest);
+
+	printf("\ndigest_before: ");
+	for (i = 0; i < SHA512_DIGEST_LENGTH; i++)
+		printf("%02x", md_before[i]);
+
+	SHA512_Update(&digest_vendor, &vendor_key[0], AES_BLOCK_SIZE);
+	SHA512_Final(&md_vendor[0], &digest_vendor);
+
+	printf("\ndigest_vendor: ");
+	for (i = 0; i < SHA512_DIGEST_LENGTH; i++)
+		printf("%02x", md_vendor[i]);
+
+	SHA512_Final(&md_post[0], &digest_post);
+
+	printf("\ndigest_post: ");
+	for (i = 0; i < SHA512_DIGEST_LENGTH; i++)
+		printf("%02x", md_post[i]);
+
+	fwrite(&footer, 1, 5, output_file);
+
+	// go back to file header and write all the digests and signatures
+	fseek(output_file, 0, SEEK_SET);
+
+	fwrite(HEAD_MAGIC, 1, HEAD_MAGIC_LEN, output_file);
+
+	// write payload length before
+	sizebuf = htonl(payload_length_before);
+	fwrite((char *) &sizebuf, 1, 4, output_file);
+
+	// write payload length post
+	payload_length_before += pad_len;
+	sizebuf = htonl(payload_length_before);
+	fwrite((char *) &sizebuf, 1, 4, output_file);
+
+	// write salt and digests
+	fwrite(salt, 1, AES_BLOCK_SIZE, output_file);
+	fwrite(&md_vendor[0], 1, SHA512_DIGEST_LENGTH, output_file);
+	fwrite(&md_before[0], 1, SHA512_DIGEST_LENGTH, output_file);
+	fwrite(&md_post[0],   1, SHA512_DIGEST_LENGTH, output_file);
+
+	// zero-fill rsa_pub field, unused in header
+	memset(sigret, 0, RSA_KEY_LENGTH_BYTES);
+	fwrite(&sigret[0], 1, RSA_KEY_LENGTH_BYTES, output_file);
+
+	// sign md_before
+	RSA_sign(NID_sha512, &md_before[0], SHA512_DIGEST_LENGTH, &sigret[0], &siglen, rsa);
+	printf("\nsigned before:\n");
+	for (i = 0; i < RSA_KEY_LENGTH_BYTES; i++)
+		printf("%02x", sigret[i]);
+	fwrite(&sigret[0], 1, RSA_KEY_LENGTH_BYTES, output_file);
+
+	// sign md_post
+	RSA_sign(NID_sha512, &md_post[0], SHA512_DIGEST_LENGTH, &sigret[0], &siglen, rsa);
+	printf("\nsigned post:\n");
+	for (i = 0; i < RSA_KEY_LENGTH_BYTES; i++)
+		printf("%02x", sigret[i]);
+	fwrite(&sigret[0], 1, RSA_KEY_LENGTH_BYTES, output_file);
+
+	fclose(output_file);
+}
+
+void image_decrypt(void)
+{
+	RSA *rsa = RSA_new();
+	BIO *rsa_public_bio = BIO_new_mem_buf(public_pem, -1);
+	char magic[4];
+	uint32_t payload_length_before, payload_length_post, pad_len;
+	char salt[AES_BLOCK_SIZE];
+	char md_vendor[SHA512_DIGEST_LENGTH];
+	char md_before[SHA512_DIGEST_LENGTH];
+	char md_post[SHA512_DIGEST_LENGTH];
+	unsigned char rsa_sign_before[RSA_KEY_LENGTH_BYTES];
+	unsigned char rsa_sign_post[RSA_KEY_LENGTH_BYTES];
+	unsigned char md_post_actual[SHA512_DIGEST_LENGTH];
+	unsigned char md_before_actual[SHA512_DIGEST_LENGTH];
+	unsigned char md_vendor_actual[SHA512_DIGEST_LENGTH];
+	SHA512_CTX digest_post;
+	SHA512_CTX digest_before;
+	SHA512_CTX digest_vendor;
+
+	printf("\ndecrypt mode\n");
+
+	RSA_print(rsa_public_bio, rsa, 0);
+	PEM_read_bio_RSAPublicKey(rsa_public_bio, &rsa, NULL, NULL);
+
+	fread(&magic, 1, HEAD_MAGIC_LEN, input_file);
+	if (strncmp(magic, HEAD_MAGIC, HEAD_MAGIC_LEN) != 0)	{
+		fprintf(stderr, "Input File header magic does not match '%s'.\n"
+			"Maybe this file is not encrypted?\n", HEAD_MAGIC);
+		exit(1);
+	}
+
+	fread((char *) &payload_length_before, 1, 4, input_file);
+	fread((char *) &payload_length_post, 1, 4, input_file);
+	payload_length_before = ntohl(payload_length_before);
+	payload_length_post   = ntohl(payload_length_post);
+
+	fread(salt, 1, AES_BLOCK_SIZE, input_file);
+	fread(md_vendor, 1, SHA512_DIGEST_LENGTH, input_file);
+	fread(md_before, 1, SHA512_DIGEST_LENGTH, input_file);
+	fread(md_post, 1, SHA512_DIGEST_LENGTH, input_file);
+
+	// skip rsa_pub
+	fread(readbuf, 1, RSA_KEY_LENGTH_BYTES, input_file);
+
+	fread(rsa_sign_before, 1, RSA_KEY_LENGTH_BYTES, input_file);
+	fread(rsa_sign_post, 1, RSA_KEY_LENGTH_BYTES, input_file);
+
+	// file should be at position HEADER_LEN now, start AES decryption
+	SHA512_Init(&digest_post);
+	SHA512_Init(&digest_before);
+
+	memcpy(&aes_iv, &salt, AES_BLOCK_SIZE);
+	AES_set_decrypt_key(&vendor_key[0], 128, &enc_key);
+	pad_len = payload_length_post - payload_length_before;
+
+	while (read_total < payload_length_post) {
+		if (read_total + BUFSIZE <= payload_length_post)
+			read_bytes = fread(&readbuf, 1, BUFSIZE, input_file);
+		else
+			read_bytes = fread(&readbuf, 1, payload_length_post - read_total, \
+				input_file);
+
+		read_total += read_bytes;
+
+		SHA512_Update(&digest_post, &readbuf[0], read_bytes);
+
+		AES_cbc_encrypt(&readbuf[0], &encbuf[0], read_bytes, &enc_key, aes_iv, AES_DECRYPT);
+
+		// only update digest_before until payload_length_before,
+		// do not hash decrypted padding
+		if (read_total > payload_length_before) {
+			// only calc hash for data before padding
+			SHA512_Update(&digest_before, &encbuf[0], read_bytes - pad_len);
+			fwrite(&encbuf[0], 1, read_bytes - pad_len, output_file);
+
+			// copy state of digest, since SHA512_Final is desctructive
+			memcpy(&digest_vendor, &digest_before, sizeof(SHA512_CTX));
+
+			// append vendor_key
+			SHA512_Update(&digest_vendor, &vendor_key[0], AES_BLOCK_SIZE);
+		} else {
+			// calc hash for all of read_bytes
+			SHA512_Update(&digest_before, &encbuf[0], read_bytes);
+			fwrite(&encbuf[0], 1, read_bytes, output_file);
+		}
+	}
+
+	fclose(output_file);
+
+	SHA512_Final(&md_post_actual[0], &digest_post);
+
+	printf("\ndigest_post: ");
+	for (i = 0; i < SHA512_DIGEST_LENGTH; i++)
+		printf("%02x", md_post_actual[i]);
+
+	if (strncmp(md_post, (char *) md_post_actual, SHA512_DIGEST_LENGTH) != 0) {
+		fprintf(stderr, "SHA512 post does not match file contents.\n");
+		exit(1);
+	}
+
+	SHA512_Final(&md_before_actual[0], &digest_before);
+
+	printf("\ndigest_before: ");
+	for (i = 0; i < SHA512_DIGEST_LENGTH; i++)
+		printf("%02x", md_before_actual[i]);
+
+	if (strncmp(md_before, (char *) md_before_actual, SHA512_DIGEST_LENGTH) != 0) {
+		fprintf(stderr, "SHA512 before does not match decrypted payload.\n");
+		exit(1);
+	}
+
+	SHA512_Final(&md_vendor_actual[0], &digest_vendor);
+
+	printf("\ndigest_vendor: ");
+	for (i = 0; i < SHA512_DIGEST_LENGTH; i++)
+		printf("%02x", md_vendor_actual[i]);
+
+	if (strncmp(md_vendor, (char *) md_vendor_actual, SHA512_DIGEST_LENGTH) != 0) {
+		fprintf(stderr, "SHA512 vendor does not match decrypted payload padded" \
+			" with vendor key.\n");
+		exit(1);
+	}
+
+	if (RSA_verify(NID_sha512, &md_before_actual[0], SHA512_DIGEST_LENGTH, \
+		&rsa_sign_before[0], RSA_KEY_LENGTH_BYTES, rsa)) {
+		printf("\nsignature before verification success");
+	} else {
+		fprintf(stderr, "Signature before verification failed.\nThe decrypted" \
+			" image file may however be flashable via bootloader recovery.\n");
+	}
+
+	if (RSA_verify(NID_sha512, &md_post_actual[0], SHA512_DIGEST_LENGTH, \
+		&rsa_sign_post[0], RSA_KEY_LENGTH_BYTES, rsa)) {
+		printf("\nsignature post verification success");
+	} else {
+		fprintf(stderr, "Signature post verification failed.\nThe decrypted" \
+			" image file may however be flashable via bootloader recovery.\n");
+	}
+
+	printf("\n");
+}
+
+int main(int argc, char **argv)
+{
+	if (argc < 2 || argc > 4) {
+		fprintf(stderr, "Usage:\n"
+			"\tdlink-sge-image infile outfile [-d: decrypt]\n\n");
+		exit(1);
+	}
+
+	input_file = fopen(argv[1], "rb");
+	if (input_file == NULL) {
+		fprintf(stderr, "Input File %s could not be opened.\n", argv[1]);
+		exit(1);
+	}
+
+	output_file = fopen(argv[2], "wb");
+	if (input_file == NULL) {
+		fprintf(stderr, "Output File %s could not be opened.\n", argv[2]);
+		exit(1);
+	}
+
+	memcpy(&aes_iv, &iv, AES_BLOCK_SIZE);
+	AES_set_decrypt_key(&key1[0], 128, &enc_key);
+	AES_cbc_encrypt(&key2[0], &vendor_key[0], AES_BLOCK_SIZE, &enc_key, \
+		aes_iv, AES_DECRYPT);
+
+	printf("\nvendor_key: ");
+	for (i = 0; i < AES_BLOCK_SIZE; i++)
+		printf("%02x", vendor_key[i]);
+
+	if (argc == 4 && strncmp(argv[3], "-d", 2) == 0)
+		image_decrypt();
+	else
+		image_encrypt();
+}
diff --git a/tools/firmware-utils/src/dlink-sge-image.h b/tools/firmware-utils/src/dlink-sge-image.h
new file mode 100644
--- /dev/null
+++ b/tools/firmware-utils/src/dlink-sge-image.h
@@ -0,0 +1,86 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+const unsigned char key1[] =
+	"\x35\x87\x90\x03\x45\x19\xf8\xc8\x23\x5d\xb6\x49\x28\x39\xa7\x3f";
+
+const unsigned char key2[] =
+	"\xc8\xd3\x2f\x40\x9c\xac\xb3\x47\xc8\xd2\x6f\xdc\xb9\x09\x0b\x3c";
+
+const unsigned char iv[] =
+	"\x98\xc9\xd8\xf0\x13\x3d\x06\x95\xe2\xa7\x09\xc8\xb6\x96\x82\xd4";
+
+const unsigned char salt[] =
+	"\x67\xc6\x69\x73\x51\xff\x4a\xec\x29\xcd\xba\xab\xf2\xfb\xe3\x46";
+
+// public.pem as found in GPL tarball
+const unsigned char public_pem[] = R"(
+-----BEGIN RSA PUBLIC KEY-----
+MIICCgKCAgEApZLuH2XFDWuazEMpx4v6QY0ePRJm344JgkLKfeofovxvbjfX6RHU
+7yUz6b2wJnW4lomEzjrJEQFnPGNFV/oWO/NaTb3k0rPUewDzlzy/pn7ZMehqnMK1
+tHVnyQ6RZ+9qkdYEu08f79UgZcGQzSy2TLNMquAB9ffGbTHAjRfoK7cDjQX+RKWh
+OOs5tbnzhR0B4Jdd6UL9Sqoq5UisTdlnFhy67RdsItz3OOrHIiDYmfkEOqAZySKZ
+MhY7h7kkC8t1IzZOncBx3LYU4PMo9ulycAx7xDUric8xswnKoYAJbbKtp9xnGKRJ
+HPuZOZyXFdWNlTVhzG3sGdDzcpHxrFOJZ5RK/n19DArbq6w9MEInTmU3bcwDYFvX
+JCQ5Al05lgqP8vk7U4xx3AcwZUQHNVzduBuibB26jhpPXSk1Cl6NpFdXlKvcynfV
+H8XaCHy8LXhZBMiuR62Ft6YkcIpBdsQ2uBGL5GOmVFA/cOEtPZjWxzN/miXaZ7In
+iRhXEHFus6zYIPOTa9DNyAA87UCqxkem7Xgu59fgq49YwGPk+Q7HJXKgts9QTn9y
+26OtlUAq1i23EJK6GJvTmszslXbAWEi5Mlb/o7QdpEQt/gyz9udnVmfXOy4UmNXN
+ZxuVyXNomTBFRObZ5Zmn6n+xat5eBDpvct+OO1IUMC154div9i2szF0CAwEAAQ==
+-----END RSA PUBLIC KEY-----
+)";
+
+// key2.pem as found in GPL tarball, decrypted via openssl using
+// PEM passphrase 12345678 to reduce code and runtime complexity
+const unsigned char key2_pem[] = R"(
+-----BEGIN RSA PRIVATE KEY-----
+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
+-----END RSA PRIVATE KEY-----
+)";
